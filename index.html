<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete Algorithms Visualization Suite</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .algorithm-selector {
            text-align: center;
            margin-bottom: 30px;
        }

        .algorithm-selector button {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .algorithm-selector button:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }

        .algorithm-selector button.active {
            background: #e74c3c;
            transform: scale(1.05);
        }

        .section {
            margin-bottom: 40px;
            padding: 20px;
            border-left: 4px solid #3498db;
            background: #f8f9fa;
            border-radius: 8px;
            display: none;
        }

        .section.active {
            display: block;
        }

        .section h2 {
            color: #2c3e50;
            margin-top: 0;
            font-size: 1.8em;
        }

        .array-display {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 20px 0;
            flex-wrap: wrap;
            gap: 5px;
        }

        .array-element {
            width: 40px;
            height: 40px;
            border: 2px solid #3498db;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            background: #ecf0f1;
            transition: all 0.3s ease;
            position: relative;
        }

        .array-element.pivot {
            background: #e74c3c !important;
            color: white;
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(231, 76, 60, 0.4);
        }

        .array-element.low {
            background: #f39c12 !important;
            color: white;
        }

        .array-element.high {
            background: #27ae60 !important;
            color: white;
        }

        .array-element.sorted {
            background: #2ecc71 !important;
            color: white;
        }

        .array-element.current {
            background: #9b59b6 !important;
            color: white;
            animation: pulse 1s infinite;
        }

        .array-element.comparing {
            background: #e67e22 !important;
            color: white;
        }

        .array-element.found {
            background: #27ae60 !important;
            color: white;
            animation: bounce 0.5s;
        }

        .array-element.swapping {
            background: #e74c3c !important;
            color: white;
            animation: shake 0.5s;
        }

        .array-element.minimum {
            background: #8e44ad !important;
            color: white;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .step {
            margin: 15px 0;
            padding: 15px;
            border-radius: 8px;
            background: white;
            border: 1px solid #ddd;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .step-title {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }

        .controls {
            text-align: center;
            margin: 20px 0;
        }

        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: all 0.3s ease;
        }

        button:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }

        button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
        }

        .explanation {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            font-style: italic;
        }

        .merge-tree {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px 0;
        }

        .merge-level {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 10px 0;
        }

        .merge-node {
            background: #ecf0f1;
            border: 2px solid #3498db;
            border-radius: 8px;
            padding: 10px;
            min-width: 100px;
            text-align: center;
            font-weight: bold;
        }

        .merge-node.splitting {
            background: #f39c12;
            color: white;
        }

        .merge-node.merging {
            background: #27ae60;
            color: white;
        }

        .search-info {
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            background: #e8f4f8;
            border-radius: 8px;
        }

        @media (max-width: 768px) {
            .array-element {
                width: 35px;
                height: 35px;
                font-size: 14px;
            }
            
            .legend {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Complete Algorithms Visualization Suite</h1>
        
        <div class="algorithm-selector">
            <button onclick="showAlgorithm('quicksort')" class="active">Quick Sort</button>
            <button onclick="showAlgorithm('mergesort')">Merge Sort</button>
            <button onclick="showAlgorithm('linearsearch')">Linear Search</button>
            <button onclick="showAlgorithm('binarysearch')">Binary Search</button>
            <button onclick="showAlgorithm('bubblesort')">Bubble Sort</button>
            <button onclick="showAlgorithm('selectionsort')">Selection Sort</button>
            <button onclick="showAlgorithm('insertionsort')">Insertion Sort</button>
        </div>

        <!-- Quick Sort Section -->
        <div class="section active" id="quicksort">
            <h2>Quick Sort</h2>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #e74c3c;"></div>
                    <span>Pivot</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #f39c12;"></div>
                    <span>Low Pointer</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #27ae60;"></div>
                    <span>High Pointer</span>
                </div>
            </div>
            <div class="controls">
                <button onclick="showQuickStep(0)">Reset</button>
                <button onclick="prevQuickStep()">Previous</button>
                <button onclick="nextQuickStep()">Next</button>
                <button onclick="autoQuickSort()">Auto Play</button>
            </div>
            <div id="quicksort-display"></div>
            <div class="explanation">
                <strong>Quick Sort:</strong> Divide-and-conquer algorithm that partitions array around a pivot element. Elements smaller than pivot go left, larger go right. Recursively sort sub-arrays.
            </div>
        </div>

        <!-- Merge Sort Section -->
        <div class="section" id="mergesort">
            <h2>Merge Sort</h2>
            <div class="controls">
                <button onclick="showMergeStep(0)">Reset</button>
                <button onclick="prevMergeStep()">Previous</button>
                <button onclick="nextMergeStep()">Next</button>
                <button onclick="autoMergeSort()">Auto Play</button>
            </div>
            <div id="mergesort-display"></div>
            <div class="explanation">
                <strong>Merge Sort:</strong> Divide-and-conquer algorithm that recursively divides array into halves, then merges sorted halves back together. Guarantees O(n log n) time complexity.
            </div>
        </div>

        <!-- Linear Search Section -->
        <div class="section" id="linearsearch">
            <h2>Linear Search</h2>
            <div class="search-info">
                <p>Search for value: <input type="number" id="linear-search-value" value="3" min="0" max="9"> 
                <button onclick="startLinearSearch()">Search</button></p>
                <p>Comparisons: <span id="linear-comparisons">0</span></p>
            </div>
            <div class="controls">
                <button onclick="resetLinearSearch()">Reset</button>
                <button onclick="nextLinearStep()">Next Step</button>
            </div>
            <div id="linearsearch-display"></div>
            <div class="explanation">
                <strong>Linear Search:</strong> Sequential search through array elements one by one until target is found or end is reached. Time complexity: O(n).
            </div>
        </div>

        <!-- Binary Search Section -->
        <div class="section" id="binarysearch">
            <h2>Binary Search</h2>
            <div class="search-info">
                <p>Search for value: <input type="number" id="binary-search-value" value="11" min="2" max="29"> 
                <button onclick="startBinarySearch()">Search</button></p>
                <p>Comparisons: <span id="binary-comparisons">0</span></p>
            </div>
            <div class="controls">
                <button onclick="resetBinarySearch()">Reset</button>
                <button onclick="nextBinaryStep()">Next Step</button>
            </div>
            <div id="binarysearch-display"></div>
            <div class="explanation">
                <strong>Binary Search:</strong> Efficient search on sorted arrays. Repeatedly divides search space in half by comparing target with middle element. Time complexity: O(log n).
            </div>
        </div>

        <!-- Bubble Sort Section -->
        <div class="section" id="bubblesort">
            <h2>Bubble Sort</h2>
            <div class="controls">
                <button onclick="showBubbleStep(0)">Reset</button>
                <button onclick="prevBubbleStep()">Previous</button>
                <button onclick="nextBubbleStep()">Next</button>
                <button onclick="autoBubbleSort()">Auto Play</button>
            </div>
            <div id="bubblesort-display"></div>
            <div class="explanation">
                <strong>Bubble Sort:</strong> Compares adjacent elements and swaps them if they're in wrong order. Repeats until no swaps are needed. Time complexity: O(n²).
            </div>
        </div>

        <!-- Selection Sort Section -->
        <div class="section" id="selectionsort">
            <h2>Selection Sort</h2>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #8e44ad;"></div>
                    <span>Minimum</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #2ecc71;"></div>
                    <span>Sorted</span>
                </div>
            </div>
            <div class="controls">
                <button onclick="showSelectionStep(0)">Reset</button>
                <button onclick="prevSelectionStep()">Previous</button>
                <button onclick="nextSelectionStep()">Next</button>
                <button onclick="autoSelectionSort()">Auto Play</button>
            </div>
            <div id="selectionsort-display"></div>
            <div class="explanation">
                <strong>Selection Sort:</strong> Finds minimum element and swaps with first position, then finds next minimum and swaps with second position, etc. Time complexity: O(n²).
            </div>
        </div>

        <!-- Insertion Sort Section -->
        <div class="section" id="insertionsort">
            <h2>Insertion Sort</h2>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #9b59b6;"></div>
                    <span>Current</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #2ecc71;"></div>
                    <span>Sorted</span>
                </div>
            </div>
            <div class="controls">
                <button onclick="showInsertionStep(0)">Reset</button>
                <button onclick="prevInsertionStep()">Previous</button>
                <button onclick="nextInsertionStep()">Next</button>
                <button onclick="autoInsertionSort()">Auto Play</button>
            </div>
            <div id="insertionsort-display"></div>
            <div class="explanation">
                <strong>Insertion Sort:</strong> Builds sorted array one element at a time by inserting each element into its correct position. Time complexity: O(n²).
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let currentAlgorithm = 'quicksort';
        let currentStep = 0;
        let isAutoPlaying = false;
        let autoInterval;

        // Data structures for different algorithms
        const quickSortSteps = [
            {
                title: "(a) The original array",
                array: [5, 2, 9, 3, 8, 4, 0, 1, 6, 7],
                pivot: 0, low: -1, high: -1,
                description: "Starting with the original array, pivot = 5"
            },
            {
                title: "(b) Initialize pivot, low, and high",
                array: [5, 2, 9, 3, 8, 4, 0, 1, 6, 7],
                pivot: 0, low: 1, high: 9,
                description: "Set pivot at index 0, low at index 1, high at index 9"
            },
            {
                title: "(c) 9 is swapped with 1",
                array: [5, 2, 1, 3, 8, 4, 0, 9, 6, 7],
                pivot: 0, low: 2, high: 7,
                description: "Low finds 9 (>pivot), high finds 1 (<pivot), swap them"
            },
            {
                title: "(d) 8 is swapped with 0",
                array: [5, 2, 1, 3, 0, 4, 8, 9, 6, 7],
                pivot: 0, low: 4, high: 6,
                description: "Continue: low finds 8 (>pivot), high finds 0 (<pivot), swap them"
            },
            {
                title: "(e) Pivot is in the right place",
                array: [4, 2, 1, 3, 0, 5, 8, 9, 6, 7],
                pivot: 5, low: -1, high: -1,
                description: "Pointers crossed, swap pivot with element at high position"
            },
            {
                title: "(f) Final sorted array",
                array: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
                pivot: -1, low: -1, high: -1,
                description: "Recursively sort sub-arrays to get final sorted array"
            }
        ];

        const mergeSortSteps = [
            {
                title: "Original array",
                array: [2, 9, 5, 4, 8, 1, 6, 7],
                description: "Starting array to be sorted"
            },
            {
                title: "Divide into halves",
                array: [[2, 9, 5, 4], [8, 1, 6, 7]],
                description: "Split array into two halves"
            },
            {
                title: "Continue dividing",
                array: [[2, 9], [5, 4], [8, 1], [6, 7]],
                description: "Keep dividing until single elements"
            },
            {
                title: "Individual elements",
                array: [[2], [9], [5], [4], [8], [1], [6], [7]],
                description: "Base case: individual elements are sorted"
            },
            {
                title: "Merge pairs",
                array: [[2, 9], [4, 5], [1, 8], [6, 7]],
                description: "Merge pairs of elements in sorted order"
            },
            {
                title: "Merge larger groups",
                array: [[2, 4, 5, 9], [1, 6, 7, 8]],
                description: "Merge the sorted pairs"
            },
            {
                title: "Final merge",
                array: [1, 2, 4, 5, 6, 7, 8, 9],
                description: "Merge the two sorted halves"
            }
        ];

        const linearSearchArray = [6, 4, 1, 9, 7, 3, 2, 8];
        const binarySearchArray = [2, 3, 5, 11, 17, 23, 29];
        const bubbleSortArray = [64, 34, 25, 12, 22, 11, 90];
        const selectionSortArray = [64, 25, 12, 22, 11, 90];
        const insertionSortArray = [5, 2, 4, 6, 1, 3];

        // State variables for different algorithms
        let linearSearchState = { current: -1, target: 3, found: false, comparisons: 0 };
        let binarySearchState = { left: 0, right: 6, mid: -1, target: 11, found: false, comparisons: 0 };
        let bubbleSortState = { array: [...bubbleSortArray], pass: 0, current: 0, swapped: false };
        let selectionSortState = { array: [...selectionSortArray], current: 0, minIndex: 0, sorted: 0 };
        let insertionSortState = { array: [...insertionSortArray], current: 1, sorted: 1 };

        function showAlgorithm(algorithm) {
            // Hide all sections
            document.querySelectorAll('.section').forEach(section => {
                section.classList.remove('active');
            });
            
            // Show selected section
            document.getElementById(algorithm).classList.add('active');
            
            // Update button states
            document.querySelectorAll('.algorithm-selector button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            currentAlgorithm = algorithm;
            currentStep = 0;
            
            // Initialize the selected algorithm
            switch(algorithm) {
                case 'quicksort':
                    showQuickStep(0);
                    break;
                case 'mergesort':
                    showMergeStep(0);
                    break;
                case 'linearsearch':
                    resetLinearSearch();
                    break;
                case 'binarysearch':
                    resetBinarySearch();
                    break;
                case 'bubblesort':
                    showBubbleStep(0);
                    break;
                case 'selectionsort':
                    showSelectionStep(0);
                    break;
                case 'insertionsort':
                    showInsertionStep(0);
                    break;
            }
        }

        function createArrayDisplay(array, special = {}) {
            const container = document.createElement('div');
            container.className = 'array-display';
            
            array.forEach((value, index) => {
                const element = document.createElement('div');
                element.className = 'array-element';
                element.textContent = value;
                
                // Apply special styling
                if (special.pivot === index) element.classList.add('pivot');
                if (special.low === index) element.classList.add('low');
                if (special.high === index) element.classList.add('high');
                if (special.current === index) element.classList.add('current');
                if (special.comparing && special.comparing.includes(index)) element.classList.add('comparing');
                if (special.found === index) element.classList.add('found');
                if (special.swapping && special.swapping.includes(index)) element.classList.add('swapping');
                if (special.minimum === index) element.classList.add('minimum');
                if (special.sorted && index < special.sorted) element.classList.add('sorted');
                
                container.appendChild(element);
            });
            
            return container;
        }

        // Quick Sort functions
        function showQuickStep(step) {
            if (step < 0 || step >= quickSortSteps.length) return;
            
            currentStep = step;
            const stepData = quickSortSteps[step];
            const display = document.getElementById('quicksort-display');
            
            display.innerHTML = '';
            
            const stepDiv = document.createElement('div');
            stepDiv.className = 'step';
            
            const title = document.createElement('div');
            title.className = 'step-title';
            title.textContent = stepData.title;
            stepDiv.appendChild(title);
            
            const arrayDisplay = createArrayDisplay(stepData.array, {
                pivot: stepData.pivot,
                low: stepData.low,
                high: stepData.high
            });
            stepDiv.appendChild(arrayDisplay);
            
            const description = document.createElement('div');
            description.textContent = stepData.description;
            stepDiv.appendChild(description);
            
            display.appendChild(stepDiv);
        }

        function nextQuickStep() {
            if (currentStep < quickSortSteps.length - 1) {
                showQuickStep(currentStep + 1);
            }
        }

        function prevQuickStep() {
            if (currentStep > 0) {
                showQuickStep(currentStep - 1);
            }
        }

        function autoQuickSort() {
            if (isAutoPlaying) {
                clearInterval(autoInterval);
                isAutoPlaying = false;
                return;
            }
            
            isAutoPlaying = true;
            autoInterval = setInterval(() => {
                if (currentStep >= quickSortSteps.length - 1) {
                    clearInterval(autoInterval);
                    isAutoPlaying = false;
                    return;
                }
                nextQuickStep();
            }, 1500);
        }

        // Merge Sort functions
        function showMergeStep(step) {
            if (step < 0 || step >= mergeSortSteps.length) return;
            
            currentStep = step;
            const stepData = mergeSortSteps[step];
            const display = document.getElementById('mergesort-display');
            
            display.innerHTML = '';
            
            const stepDiv = document.createElement('div');
            stepDiv.className = 'step';
            
            const title = document.createElement('div');
            title.className = 'step-title';
            title.textContent = stepData.title;
            stepDiv.appendChild(title);
            
            if (Array.isArray(stepData.array[0])) {
                // Multi-dimensional array display
                const treeDiv = document.createElement('div');
                treeDiv.className = 'merge-tree';
                
                const level = document.createElement('div');
                level.className = 'merge-level';
                
                stepData.array.forEach(subArray => {
                    const node = document.createElement('div');
                    node.className = 'merge-node';
                    node.textContent = Array.isArray(subArray) ? subArray.join(' ') : subArray;
                    level.appendChild(node);
                });
                
                treeDiv.appendChild(level);
                stepDiv.appendChild(treeDiv);
            } else {
                // Single array display
                const arrayDisplay = createArrayDisplay(stepData.array);
                stepDiv.appendChild(arrayDisplay);
            }
            
            const description = document.createElement('div');
            description.textContent = stepData.description;
            stepDiv.appendChild(description);
            
            display.appendChild(stepDiv);
        }

        function nextMergeStep() {
            if (currentStep < mergeSortSteps.length - 1) {
                showMergeStep(currentStep + 1);
            }
        }

        function prevMergeStep() {
            if (currentStep > 0) {
                showMergeStep(currentStep - 1);
            }
        }

        function autoMergeSort() {
            if (isAutoPlaying) {
                clearInterval(autoInterval);
                isAutoPlaying = false;
                return;
            }
            
            isAutoPlaying = true;
            autoInterval = setInterval(() => {
                if (currentStep >= mergeSortSteps.length - 1) {
                    clearInterval(autoInterval);
                    isAutoPlaying = false;
                    return;
                }
                nextMergeStep();
            }, 2000);
        }

        // Linear Search functions
        function resetLinearSearch() {
            linearSearchState = { current: -1, target: 3, found: false, comparisons: 0 };
            document.getElementById('linear-comparisons').textContent = '0';
            showLinearSearchStep();
        }

        function startLinearSearch() {
            const target = parseInt(document.getElementById('linear-search-value').value);
            linearSearchState = { current: -1, target: target, found: false, comparisons: 0 };
            document.getElementById('linear-comparisons').textContent = '0';
            showLinearSearchStep();
        }

        function showLinearSearchStep() {
            const display = document.getElementById('linearsearch-display');
            display.innerHTML = '';
            
            const stepDiv = document.createElement('div');
            stepDiv.className = 'step';
            
            const title = document.createElement('div');
            title.className = 'step-title';
            title.textContent = `Linear Search for ${linearSearchState.target}`;
            stepDiv.appendChild(title);
            
            const special = { current: linearSearchState.current };
            if (linearSearchState.found) {
                special.found = linearSearchState.current;
            }
            
            const arrayDisplay = createArrayDisplay(linearSearchArray, special);
            stepDiv.appendChild(arrayDisplay);
            
            let description = '';
            if (linearSearchState.current === -1) {
                description = 'Ready to start searching...';
            } else if (linearSearchState.found) {
                description = `Found ${linearSearchState.target} at index ${linearSearchState.current}!`;
            } else if (linearSearchState.current >= linearSearchArray.length) {
                description = `${linearSearchState.target} not found in array.`;
            } else {
                description = `Checking index ${linearSearchState.current}: ${linearSearchArray[linearSearchState.current]} ${linearSearchArray[linearSearchState.current] === linearSearchState.target ? '= ' : '≠ '}${linearSearchState.target}`;
            }
            
            const descDiv = document.createElement('div');
            descDiv.textContent = description;
            stepDiv.appendChild(descDiv);
            
            display.appendChild(stepDiv);
        }

        function nextLinearStep() {
            if (linearSearchState.found || linearSearchState.current >= linearSearchArray.length) return;
            
            linearSearchState.current++;
            linearSearchState.comparisons++;
            
            if (linearSearchState.current < linearSearchArray.length) {
                if (linearSearchArray[linearSearchState.current] === linearSearchState.target) {
                    linearSearchState.found = true;
                }
            }
            
            document.getElementById('linear-comparisons').textContent = linearSearchState.comparisons;
            showLinearSearchStep();
        }

        // Binary Search functions
        function resetBinarySearch() {
            binarySearchState = { left: 0, right: 6, mid: -1, target: 11, found: false, comparisons: 0 };
            document.getElementById('binary-comparisons').textContent = '0';
            showBinarySearchStep();
        }

        function startBinarySearch() {
            const target = parseInt(document.getElementById('binary-search-value').value);
            binarySearchState = { left: 0, right: 6, mid: -1, target: target, found: false, comparisons: 0 };
            document.getElementById('binary-comparisons').textContent = '0';
            showBinarySearchStep();
        }

        function showBinarySearchStep() {
            const display = document.getElementById('binarysearch-display');
            display.innerHTML = '';
            
            const stepDiv = document.createElement('div');
            stepDiv.className = 'step';
            
            const title = document.createElement('div');
            title.className = 'step-title';
            title.textContent = `Binary Search for ${binarySearchState.target}`;
            stepDiv.appendChild(title);
            
            const special = {};
            if (binarySearchState.mid !== -1) {
                special.current = binarySearchState.mid;
            }
            if (binarySearchState.found) {
                special.found = binarySearchState.mid;
            }
            
            const arrayDisplay = createArrayDisplay(binarySearchArray, special);
            stepDiv.appendChild(arrayDisplay);
            
            let description = '';
            if (binarySearchState.mid === -1) {
                description = `Ready to start searching. Left: ${binarySearchState.left}, Right: ${binarySearchState.right}`;
            } else if (binarySearchState.found) {
                description = `Found ${binarySearchState.target} at index ${binarySearchState.mid}!`;
            } else if (binarySearchState.left > binarySearchState.right) {
                description = `${binarySearchState.target} not found in array.`;
            } else {
                const midValue = binarySearchArray[binarySearchState.mid];
                description = `Mid: ${binarySearchState.mid} (${midValue}). ${midValue === binarySearchState.target ? 'Found!' : midValue < binarySearchState.target ? 'Search right half' : 'Search left half'}`;
            }
            
            const descDiv = document.createElement('div');
            descDiv.textContent = description;
            stepDiv.appendChild(descDiv);
            
            display.appendChild(stepDiv);
        }

        function nextBinaryStep() {
            if (binarySearchState.found || binarySearchState.left > binarySearchState.right) return;
            
            binarySearchState.mid = Math.floor((binarySearchState.left + binarySearchState.right) / 2);
            binarySearchState.comparisons++;
            
            const midValue = binarySearchArray[binarySearchState.mid];
            
            if (midValue === binarySearchState.target) {
                binarySearchState.found = true;
            } else if (midValue < binarySearchState.target) {
                binarySearchState.left = binarySearchState.mid + 1;
            } else {
                binarySearchState.right = binarySearchState.mid - 1;
            }
            
            document.getElementById('binary-comparisons').textContent = binarySearchState.comparisons;
            showBinarySearchStep();
        }

        // Bubble Sort functions
        function showBubbleStep(step) {
            if (step === 0) {
                bubbleSortState = { array: [...bubbleSortArray], pass: 0, current: 0, swapped: false };
                currentStep = 0;
            }
            
            const display = document.getElementById('bubblesort-display');
            display.innerHTML = '';
            
            const stepDiv = document.createElement('div');
            stepDiv.className = 'step';
            
            const title = document.createElement('div');
            title.className = 'step-title';
            title.textContent = `Bubble Sort - Pass ${bubbleSortState.pass + 1}`;
            stepDiv.appendChild(title);
            
            const special = {};
            if (bubbleSortState.current < bubbleSortState.array.length - 1) {
                special.comparing = [bubbleSortState.current, bubbleSortState.current + 1];
            }
            special.sorted = bubbleSortState.array.length - bubbleSortState.pass;
            
            const arrayDisplay = createArrayDisplay(bubbleSortState.array, special);
            stepDiv.appendChild(arrayDisplay);
            
            let description = '';
            if (bubbleSortState.current >= bubbleSortState.array.length - 1 - bubbleSortState.pass) {
                description = `Pass ${bubbleSortState.pass + 1} complete. ${bubbleSortState.swapped ? 'Continue to next pass.' : 'Array is sorted!'}`;
            } else {
                const curr = bubbleSortState.array[bubbleSortState.current];
                const next = bubbleSortState.array[bubbleSortState.current + 1];
                description = `Comparing ${curr} and ${next}. ${curr > next ? 'Swap needed.' : 'No swap needed.'}`;
            }
            
            const descDiv = document.createElement('div');
            descDiv.textContent = description;
            stepDiv.appendChild(descDiv);
            
            display.appendChild(stepDiv);
        }

        function nextBubbleStep() {
            if (bubbleSortState.pass >= bubbleSortState.array.length - 1) return;
            
            if (bubbleSortState.current < bubbleSortState.array.length - 1 - bubbleSortState.pass) {
                // Compare and swap if needed
                if (bubbleSortState.array[bubbleSortState.current] > bubbleSortState.array[bubbleSortState.current + 1]) {
                    // Swap
                    const temp = bubbleSortState.array[bubbleSortState.current];
                    bubbleSortState.array[bubbleSortState.current] = bubbleSortState.array[bubbleSortState.current + 1];
                    bubbleSortState.array[bubbleSortState.current + 1] = temp;
                    bubbleSortState.swapped = true;
                }
                bubbleSortState.current++;
            } else {
                // End of pass
                if (!bubbleSortState.swapped) {
                    // Array is sorted
                    showBubbleStep(0);
                    return;
                }
                bubbleSortState.pass++;
                bubbleSortState.current = 0;
                bubbleSortState.swapped = false;
            }
            
            currentStep++;
            showBubbleStep(currentStep);
        }

        function prevBubbleStep() {
            if (currentStep > 0) {
                currentStep--;
                // This is simplified - in a full implementation you'd need to track state history
                showBubbleStep(0);
            }
        }

        function autoBubbleSort() {
            if (isAutoPlaying) {
                clearInterval(autoInterval);
                isAutoPlaying = false;
                return;
            }
            
            isAutoPlaying = true;
            autoInterval = setInterval(() => {
                nextBubbleStep();
                if (bubbleSortState.pass >= bubbleSortState.array.length - 1) {
                    clearInterval(autoInterval);
                    isAutoPlaying = false;
                }
            }, 1000);
        }

        // Selection Sort functions
        function showSelectionStep(step) {
            if (step === 0) {
                selectionSortState = { array: [...selectionSortArray], current: 0, minIndex: 0, sorted: 0 };
                currentStep = 0;
            }
            
            const display = document.getElementById('selectionsort-display');
            display.innerHTML = '';
            
            const stepDiv = document.createElement('div');
            stepDiv.className = 'step';
            
            const title = document.createElement('div');
            title.className = 'step-title';
            title.textContent = `Selection Sort - Position ${selectionSortState.sorted}`;
            stepDiv.appendChild(title);
            
            const special = {
                current: selectionSortState.current,
                minimum: selectionSortState.minIndex,
                sorted: selectionSortState.sorted
            };
            
            const arrayDisplay = createArrayDisplay(selectionSortState.array, special);
            stepDiv.appendChild(arrayDisplay);
            
            let description = '';
            if (selectionSortState.sorted >= selectionSortState.array.length) {
                description = 'Array is completely sorted!';
            } else {
                description = `Finding minimum in unsorted portion. Current minimum: ${selectionSortState.array[selectionSortState.minIndex]} at index ${selectionSortState.minIndex}`;
            }
            
            const descDiv = document.createElement('div');
            descDiv.textContent = description;
            stepDiv.appendChild(descDiv);
            
            display.appendChild(stepDiv);
        }

        function nextSelectionStep() {
            if (selectionSortState.sorted >= selectionSortState.array.length) return;
            
            if (selectionSortState.current < selectionSortState.array.length) {
                // Find minimum
                if (selectionSortState.array[selectionSortState.current] < selectionSortState.array[selectionSortState.minIndex]) {
                    selectionSortState.minIndex = selectionSortState.current;
                }
                selectionSortState.current++;
            } else {
                // Swap minimum with first unsorted element
                const temp = selectionSortState.array[selectionSortState.sorted];
                selectionSortState.array[selectionSortState.sorted] = selectionSortState.array[selectionSortState.minIndex];
                selectionSortState.array[selectionSortState.minIndex] = temp;
                
                selectionSortState.sorted++;
                selectionSortState.current = selectionSortState.sorted;
                selectionSortState.minIndex = selectionSortState.sorted;
            }
            
            currentStep++;
            showSelectionStep(currentStep);
        }

        function prevSelectionStep() {
            if (currentStep > 0) {
                currentStep--;
                showSelectionStep(0);
            }
        }

        function autoSelectionSort() {
            if (isAutoPlaying) {
                clearInterval(autoInterval);
                isAutoPlaying = false;
                return;
            }
            
            isAutoPlaying = true;
            autoInterval = setInterval(() => {
                nextSelectionStep();
                if (selectionSortState.sorted >= selectionSortState.array.length) {
                    clearInterval(autoInterval);
                    isAutoPlaying = false;
                }
            }, 1000);
        }

        // Insertion Sort functions
        function showInsertionStep(step) {
            if (step === 0) {
                insertionSortState = { array: [...insertionSortArray], current: 1, sorted: 1 };
                currentStep = 0;
            }
            
            const display = document.getElementById('insertionsort-display');
            display.innerHTML = '';
            
            const stepDiv = document.createElement('div');
            stepDiv.className = 'step';
            
            const title = document.createElement('div');
            title.className = 'step-title';
            title.textContent = `Insertion Sort - Inserting element ${insertionSortState.current}`;
            stepDiv.appendChild(title);
            
            const special = {
                current: insertionSortState.current,
                sorted: insertionSortState.sorted
            };
            
            const arrayDisplay = createArrayDisplay(insertionSortState.array, special);
            stepDiv.appendChild(arrayDisplay);
            
            let description = '';
            if (insertionSortState.current >= insertionSortState.array.length) {
                description = 'Array is completely sorted!';
            } else {
                description = `Inserting ${insertionSortState.array[insertionSortState.current]} into sorted portion A[0..${insertionSortState.sorted - 1}]`;
            }
            
            const descDiv = document.createElement('div');
            descDiv.textContent = description;
            stepDiv.appendChild(descDiv);
            
            display.appendChild(stepDiv);
        }

        function nextInsertionStep() {
            if (insertionSortState.current >= insertionSortState.array.length) return;
            
            // Insert current element into sorted portion
            const key = insertionSortState.array[insertionSortState.current];
            let j = insertionSortState.current - 1;
            
            while (j >= 0 && insertionSortState.array[j] > key) {
                insertionSortState.array[j + 1] = insertionSortState.array[j];
                j--;
            }
            insertionSortState.array[j + 1] = key;
            
            insertionSortState.current++;
            insertionSortState.sorted++;
            
            currentStep++;
            showInsertionStep(currentStep);
        }

        function prevInsertionStep() {
            if (currentStep > 0) {
                currentStep--;
                showInsertionStep(0);
            }
        }

        function autoInsertionSort() {
            if (isAutoPlaying) {
                clearInterval(autoInterval);
                isAutoPlaying = false;
                return;
            }
            
            isAutoPlaying = true;
            autoInterval = setInterval(() => {
                nextInsertionStep();
                if (insertionSortState.current >= insertionSortState.array.length) {
                    clearInterval(autoInterval);
                    isAutoPlaying = false;
                }
            }, 1000);
        }

        // Initialize the first algorithm
        document.addEventListener('DOMContentLoaded', function() {
            showQuickStep(0);
        });
    </script>
</body>
</html>
